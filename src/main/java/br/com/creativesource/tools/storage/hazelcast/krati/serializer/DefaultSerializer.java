
package br.com.creativesource.tools.storage.hazelcast.krati.serializer;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.Closeable;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectStreamClass;
import java.io.Serializable;

import krati.io.SerializationException;
import krati.io.Serializer;

import org.apache.log4j.Logger;

import br.com.creativesource.tools.storage.hazelcast.krati.util.IOHelper;

/**
 * @author sleipnir
 * 
 */
public class DefaultSerializer<T extends Serializable> implements Serializer<T> {

	private static final Logger LOG = Logger
			.getLogger(DefaultSerializer.class);
	
	Closeable closeable;

	/**
	 * Serialize an object into a byte array.
	 * 
	 * @param object
	 *            - an object to be serialized by this Serializer.
	 * @return a byte array which is the raw representation of an object.
	 */
	public byte[] serialize(T object) throws SerializationException {
		
		byte[] result = null;

		if (object == null) {
			return null;
		}

		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		ObjectOutputStream oos = null;
		try {
			oos = new ObjectOutputStream(baos);
			oos.writeObject(object);
			result = baos.toByteArray();
		} catch (IOException e) {
			LOG.warn("Error while serializing object. Null will be used.", e);
		} finally {
			IOHelper.close(oos);
			IOHelper.close(baos);
		}
		return result;
	}

	/**
	 * Deserialize an object from its raw bytes generated by {
	 * {@link #serialize(Object)}.
	 * 
	 * @param binary
	 *            - the raw bytes from which an object is constructed.
	 * @return an object constructed from the raw bytes.
	 * @throws SerializationException
	 *             if the object cannot be constructed from the raw bytes.
	 */
	public T deserialize(byte[] binary) throws SerializationException {
		T result = null;
		ObjectInputStream ois = null;

		if (binary == null) {
			return null;
		}

		ByteArrayInputStream bais = new ByteArrayInputStream(binary);
		final ClassLoader classLoader = Thread.currentThread()
				.getContextClassLoader();
		try {
			ois = new ObjectInputStream(bais) {
				@Override
				public Class<?> resolveClass(ObjectStreamClass desc)
						throws IOException, ClassNotFoundException {
					try {
						return classLoader.loadClass(desc.getName());
					} catch (Exception e) {
					}
					return super.resolveClass(desc);
				}
			};
			result = (T) ois.readObject();
		} catch (IOException e) {
			LOG.warn("Error while deserializing object. Null will be used.", e);
		} catch (ClassNotFoundException e) {
			LOG.warn(
					"Could not find class while deserializing object. Null will be used.",
					e);
		} finally {
			IOHelper.close(ois);
			IOHelper.close(bais);
		}
		return result;
	}

}